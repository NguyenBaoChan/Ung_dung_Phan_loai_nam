# -*- coding: utf-8 -*-
"""Xu_ly_du_lieu.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eeexRAJglgaqgiPIJ_IRMHIM5r6s3NHs
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import LabelEncoder, StandardScaler

#load bộ dữ liệu lên, in ra 26 dòng đầu tiên
path="mushrooms_clean.csv"
data = pd.read_csv(path)
data.head(26) #Đọc 26 dong đầu tiên trong bộ dũ liệu

#Xem bộ dữ liệu có độ dài là bao nhiêu, bao nhiêu thuộc tính
data.shape

#chia header thành 1 danh sách với các cột tương ứng
header = data.columns.tolist()  # Chuyển Index thành danh sách
print(header)

#check xem coi bộ dữ liệu có bị gia trị null hay không ==> true: là có , false: là không
data.isnull().values.any()

#Xem coi có bao nhiêu giá trị null trong bộ dữ liệu của mình
data.isnull().sum().sum()

#Check xem các cột cụ thể có bao nhiêu giá trị null
data.isnull().sum()

#Xem các dòng cụ thể, coi dòng nào giá trị nào bị null
data[pd.isnull(data).any(axis=1)]

# Giả sử bộ dữ liệu có giá thiếu hay bị null thì ta tiaans hành xử lý dữ liệu như sau

# # Thay thế các biến định lượng có giá trị null bằng giá trị trung bình
# numeric_columns = ["Các biến định lượng"]
# for column in numeric_columns:
#     data[column].fillna(data[column].mean(), inplace=True)

# # Thay thế các biến phân loại có giá trị null bằng giá trị mode
# categorical_columns = ["Các biến phân loại"]
# for column in categorical_columns:
#     data[column].fillna(data[column].mode()[0], inplace=True)

# # Kiểm tra lại các giá trị null
# null_counts = data.isnull().sum()

# # In ra số lượng giá trị null trong từng cột
# print(null_counts)

#Nấm có nhãn "Edible" (ăn được) và nấm có nhãn "Poisonous" (độc).
data["class"].value_counts()

import matplotlib.pyplot as plt

# Pie chart, where the slices will be ordered and plotted counter-clockwise:
plt.figure(figsize=(6, 6))
# explosion
plt.pie(data['class'].value_counts(), colors=['#6A9838', '#af1222'], labels=['Edible', 'Poisonous'], autopct='%1.1f%%', startangle=90, pctdistance=0.85, explode=(0.05, 0.05), shadow=True)
# draw circle
centre_circle = plt.Circle((0, 0), 0.70, fc='white')
fig = plt.gcf()
fig.gca().add_artist(centre_circle)
# Equal aspect ratio ensures that pie is drawn as a circle
plt.tight_layout()
plt.show()

# The correlation between cap color and Edible or Poisonous
sns.catplot(x="cap_color", hue="class", col="class", data=data, kind="count", height=8, aspect=0.8, palette=['#af1222', '#6A9838'])

# Loại bỏ cột "veil_type" khỏi DataFrame data.
data = data.drop(["veil_type"], axis = 1)

#Tách các biến phụ thuộc và biến độc lập.
features = data.columns
target = 'class'
features = list(features.drop(target))
features

fig, axs = plt.subplots(nrows=11, ncols=2, figsize=(15, 66))

for f, ax in zip(features, axs.ravel()):
    sns.countplot(x=f, hue='class', data=data, ax = ax)

#tiền xử lý - thay đổi giá trị thành số bằng bộ mã hóa nhãn. chuyển đổi các biến phân loại (categorical variables) thành dạng số bằng phương pháp mã hóa nhãn (Label encoding) bằng sử dụng thư viện scikit-learn
def Label_enc(feat):
    LabelE = LabelEncoder() #Tạo một đối tượng của lớp
    # ==> Đối tượng này sẽ được sử dụng để thực hiện mã hóa nhãn cho từng cột dữ liệu.
    LabelE.fit(feat)
    print(feat.name,LabelE.classes_)
    return LabelE.transform(feat)

for col in data.columns:
    data[str(col)] = Label_enc(data[str(col)])

data.describe().transpose()

data.head()

#Split the data to y and x with x is without the class's.
y = data['class']#Dòng này tạo một biến y để lưu trữ cột "class" của DataFrame data.
X = data.drop('class', axis=1) #Dòng này tạo một biến X để lưu trữ DataFrame mới, trong đó đã loại bỏ cột "class" bằng cách sử dụng phương thức drop
#*********************************************************************************************************************
# y = df['class']: Biến y thường đại diện cho biến mục tiêu (target) mà bạn muốn dự đoán hoặc phân loại.
# X = df.drop('class', axis=1):Cột "class" là biến mục tiêu mà bạn muốn dự đoán, và X chứa tất cả các biến độc lập (features) mà bạn sẽ sử dụng để xây dựng mô hình dự đoán biến mục tiêu.

# Kết quả của đoạn code này là bạn đã chia dữ liệu thành hai bộ dữ liệu:
# y: Bộ dữ liệu chứa biến mục tiêu (target), trong trường hợp này là cột "class".
# X: Bộ dữ liệu chứa các biến độc lập (features) đã loại bỏ cột "class".

X.head()

#Heatmap of all features.
plt.figure(figsize=(15,15))
sns.heatmap(data.corr(),linewidths=.1,cmap="inferno", annot=True);

